/**
 * Test utilities and helpers for BeamBox tests
 */

/**
 * Compare buffer content as hex strings
 */
export function expectHex(actual: Buffer, expected: string): void {
  const actualHex = actual.toString("hex").toLowerCase();
  const expectedHex = expected.toLowerCase().replace(/\s/g, "");
  
  if (actualHex !== expectedHex) {
    throw new Error(
      `Hex mismatch:\nExpected: ${expectedHex}\nActual:   ${actualHex}`
    );
  }
}

/**
 * Convert hex string to Buffer
 */
export function hexToBuffer(hex: string): Buffer {
  return Buffer.from(hex.replace(/\s/g, ""), "hex");
}

/**
 * Create a test JPEG buffer (minimal valid JPEG)
 * This is a 1x1 pixel red JPEG
 */
export function createTestJpeg(size: number = 631): Buffer {
  // Minimal valid JPEG header + data
  const minimalJpeg = Buffer.from([
    0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
    0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43,
    0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
    0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12,
    0x13, 0x0f, 0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d, 0x1a, 0x1c, 0x1c, 0x20,
    0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29,
    0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d, 0x38, 0x32,
    0x3c, 0x2e, 0x33, 0x34, 0x32, 0xff, 0xc0, 0x00, 0x0b, 0x08, 0x00, 0x01,
    0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0xff, 0xc4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xda, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3f, 0x00,
    0x37, 0xff, 0xd9,
  ]);

  if (size <= minimalJpeg.length) {
    return minimalJpeg;
  }

  // Pad to requested size by inserting data before EOI marker
  const padding = Buffer.alloc(size - minimalJpeg.length, 0xff);
  const withoutEOI = minimalJpeg.subarray(0, minimalJpeg.length - 2);
  const EOI = minimalJpeg.subarray(minimalJpeg.length - 2);
  return Buffer.concat([withoutEOI, padding, EOI]);
}

/**
 * Create a test PNG buffer (minimal valid PNG)
 * This is a 1x1 pixel transparent PNG
 */
export function createTestPng(): Buffer {
  return Buffer.from([
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
    0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4, 0x89, 0x00, 0x00, 0x00,
    0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x00, 0x01, 0x00, 0x00,
    0x05, 0x00, 0x01, 0x0d, 0x0a, 0x2d, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x49,
    0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
  ]);
}

/**
 * Calculate checksum for protocol packet
 */
export function calculateChecksum(data: Buffer): number {
  let sum = 0;
  for (let i = 0; i < data.length; i++) {
    sum += data[i]!;
  }
  return (-sum & 0xff);
}

/**
 * Create a mock logger that captures log calls
 */
export class MockLogger {
  public logs: Array<{ level: string; message: string; args: any[] }> = [];

  info(message: string, ...args: any[]) {
    this.logs.push({ level: "info", message, args });
  }

  debug(message: string, ...args: any[]) {
    this.logs.push({ level: "debug", message, args });
  }

  warning(message: string, ...args: any[]) {
    this.logs.push({ level: "warning", message, args });
  }

  error(message: string, ...args: any[]) {
    this.logs.push({ level: "error", message, args });
  }

  clear() {
    this.logs = [];
  }

  hasLog(level: string, messageFragment: string): boolean {
    return this.logs.some(
      (log) => log.level === level && log.message.includes(messageFragment)
    );
  }
}
